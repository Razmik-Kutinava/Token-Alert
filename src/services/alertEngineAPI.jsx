// API –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Alert Engine C Backend
class AlertEngineAPI {
  constructor() {
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–µ
    const hostname = window.location.hostname;
    const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1';
    
    console.log('üîß Alert Engine API:', {
      hostname: hostname,
      isLocalhost: isLocalhost,
      enabled: true, // –¢–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –≤–∫–ª—é—á–µ–Ω
      baseURL: this.baseURL,
      wsURL: this.wsURL,
      useMockData: this.useMockData
    });
    
    if (isLocalhost) {
      // Localhost - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π mock —Å–µ—Ä–≤–µ—Ä
      this.baseURL = import.meta.env.VITE_ALERT_ENGINE_HTTP_URL || 'http://localhost:8090';
      this.wsURL = import.meta.env.VITE_ALERT_ENGINE_WS_URL || 'ws://localhost:8091';
      this.isAlertEngineEnabled = true;
      this.useMockData = false;
    } else {
      // Production - –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ mock –¥–∞–Ω–Ω—ã–µ
      this.baseURL = null;
      this.wsURL = null;
      this.isAlertEngineEnabled = true;
      this.useMockData = true;
    }
    
    this.websocket = null;
    this.subscribers = new Set();
    
    // Mock –¥–∞–Ω–Ω—ã–µ –¥–ª—è production
    this.mockAlerts = [
      {
        id: '1',
        symbol: 'BTC',
        condition: 'above',
        target_price: 65000,
        current_price: 63245,
        is_active: true,
        created_at: Date.now() - 86400000,
        priority: 'high'
      },
      {
        id: '2',
        symbol: 'ETH',
        condition: 'below',
        target_price: 3000,
        current_price: 3456,
        is_active: true,
        created_at: Date.now() - 43200000,
        priority: 'medium'
      }
    ];
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ Alert Engine
  isAlertEngineAvailable() {
    // –¢–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–µ–Ω (–ª–∏–±–æ —Ä–µ–∞–ª—å–Ω—ã–π API, –ª–∏–±–æ mock)
    return this.isAlertEngineEnabled;
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ WebSocket
  isWebSocketAvailable() {
    return this.isAlertEngineEnabled && this.wsURL !== null;
  }

  // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket –¥–ª—è real-time —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
  connectWebSocket() {
    if (!this.isWebSocketAvailable() || this.websocket) {
      if (!this.wsURL) {
        console.log('üîá WebSocket disabled in production (using mock data)');
      }
      return;
    }

    console.log('üîå Connecting to WebSocket:', this.wsURL);
    this.websocket = new WebSocket(this.wsURL);
    
    this.websocket.onopen = () => {
      console.log('Alert Engine WebSocket connected');
    };

    this.websocket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.notifySubscribers(data);
      } catch (error) {
        console.error('WebSocket message parse error:', error);
      }
    };

    this.websocket.onclose = () => {
      console.log('Alert Engine WebSocket disconnected');
      this.websocket = null;
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ WebSocket –¥–æ—Å—Ç—É–ø–µ–Ω)
      if (this.isWebSocketAvailable()) {
        setTimeout(() => this.connectWebSocket(), 5000);
      }
    };

    this.websocket.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
  notifySubscribers(data) {
    this.subscribers.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error('Subscriber callback error:', error);
      }
    });
  }

  // Mock –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è production
  async handleMockRequest(endpoint, options = {}) {
    console.log('üé≠ Mock request:', endpoint, options.method || 'GET');
    
    try {
      // –°–∏–º—É–ª–∏—Ä—É–µ–º –∑–∞–¥–µ—Ä–∂–∫—É —Å–µ—Ç–∏
      await new Promise(resolve => setTimeout(resolve, 100));
      
      if (endpoint === '/api/health') {
        return { status: 'ok', mode: 'mock', timestamp: Date.now() };
      }
    
    if (endpoint === '/api/alerts') {
      if (options.method === 'POST') {
        const requestData = JSON.parse(options.body || '{}');
        const newAlert = {
          id: String(Date.now()),
          symbol: requestData.symbol || 'BTC',
          condition: requestData.condition || 'above',
          target_price: requestData.target_price || 0,
          current_price: requestData.current_price || 0,
          alert_type: requestData.alert_type || 'price',
          priority: requestData.priority || 'medium',
          category: requestData.category || 'price_monitoring',
          created_at: Date.now(),
          is_active: true
        };
        this.mockAlerts.push(newAlert);
        return { status: 'success', alert: newAlert };
      }
      return { status: 'success', alerts: this.mockAlerts, total: this.mockAlerts.length };
    }
    
    if (endpoint.startsWith('/api/alerts/') && options.method === 'DELETE') {
      const id = endpoint.split('/').pop();
      this.mockAlerts = this.mockAlerts.filter(a => a.id !== id);
      return { status: 'success', message: 'Alert deleted' };
    }
    
    if (endpoint === '/api/market-data') {
      return {
        status: 'success',
        data: {
          BTC: { price: 63245.67, change_24h: 2.34 },
          ETH: { price: 3456.78, change_24h: -1.23 },
          SOL: { price: 145.23, change_24h: 5.67 }
        }
      };
    }
    
    if (endpoint === '/api/stats') {
      return {
        status: 'success',
        stats: {
          active_alerts: this.mockAlerts.filter(a => a.is_active).length,
          total_alerts: this.mockAlerts.length,
          monitored_symbols: [...new Set(this.mockAlerts.map(a => a.symbol))].length,
          uptime: 3600,
          last_update: Date.now()
        }
      };
    }
    
    throw new Error(`Mock endpoint not implemented: ${endpoint}`);
    } catch (error) {
      console.error('Mock request error:', error);
      throw error;
    }
  }

  // HTTP –∑–∞–ø—Ä–æ—Å—ã –∫ C API
  async request(endpoint, options = {}) {
    // –í production –∏—Å–ø–æ–ª—å–∑—É–µ–º mock –¥–∞–Ω–Ω—ã–µ
    if (this.useMockData) {
      return this.handleMockRequest(endpoint, options);
    }
    
    if (!this.isAlertEngineAvailable()) {
      console.warn('Alert Engine not available');
      throw new Error('Alert Engine not available');
    }
    
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        return await response.json();
      } else {
        return await response.text();
      }
    } catch (error) {
      console.error(`API request failed: ${endpoint}`, error);
      throw error;
    }
  }

  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∞–ª–µ—Ä—Ç—ã
  async getAlerts() {
    return this.request('/api/alerts');
  }

  // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∞–ª–µ—Ä—Ç
  async createAlert(alertData) {
    return this.request('/api/alerts', {
      method: 'POST',
      body: JSON.stringify(alertData)
    });
  }

  // –£–¥–∞–ª–∏—Ç—å –∞–ª–µ—Ä—Ç
  async deleteAlert(alertId) {
    return this.request(`/api/alerts/${alertId}`, {
      method: 'DELETE'
    });
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Ä—ã–Ω–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
  async getMarketData() {
    return this.request('/api/market-data');
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã
  async getCryptoPrices(symbols) {
    const symbolsParam = Array.isArray(symbols) ? symbols.join(',') : symbols;
    return this.request(`/api/prices?symbols=${symbolsParam}`);
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É Alert Engine
  async getStats() {
    return this.request('/api/stats');
  }

  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–∞
  async getHealth() {
    return this.request('/api/health');
  }
}

// Singleton instance
export const alertEngineAPI = new AlertEngineAPI();

// React Hook –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Alert Engine
import { createSignal, createEffect, onCleanup } from 'solid-js';

export function useAlertEngine() {
  const [alerts, setAlerts] = createSignal([]);
  const [marketData, setMarketData] = createSignal({});
  const [loading, setLoading] = createSignal(false);
  const [error, setError] = createSignal(null);
  const [connected, setConnected] = createSignal(false);

  // –ó–∞–≥—Ä—É–∑–∫–∞ –∞–ª–µ—Ä—Ç–æ–≤
  const loadAlerts = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await alertEngineAPI.getAlerts();
      setAlerts(data.alerts || []);
    } catch (err) {
      setError(err.message);
      console.error('Failed to load alerts:', err);
    } finally {
      setLoading(false);
    }
  };

  // –°–æ–∑–¥–∞–Ω–∏–µ –∞–ª–µ—Ä—Ç–∞
  const createAlert = async (alertData) => {
    try {
      setError(null);
      console.log('üîß Creating alert with data:', alertData);
      const response = await alertEngineAPI.createAlert(alertData);
      console.log('üìù Alert creation response:', response);
      
      // API –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç { status: 'success', alert: {...} }
      const newAlert = response.alert || response;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∞–ª–µ—Ä—Ç —Å —Ç–∞–∫–∏–º ID –µ—â–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
      setAlerts(prev => {
        const exists = prev.find(alert => alert.id === newAlert.id);
        if (exists) {
          console.warn('‚ö†Ô∏è Alert with ID already exists, skipping:', newAlert.id);
          return prev;
        }
        console.log('‚úÖ Adding new alert to list:', newAlert.id);
        return [...prev, newAlert];
      });
      
      return newAlert;
    } catch (err) {
      setError(err.message);
      throw err;
    }
  };

  // –£–¥–∞–ª–µ–Ω–∏–µ –∞–ª–µ—Ä—Ç–∞
  const deleteAlert = async (alertId) => {
    try {
      if (!alertId) {
        console.error('Alert ID is undefined');
        throw new Error('Alert ID is required');
      }
      
      setError(null);
      console.log('üóëÔ∏è Deleting alert with ID:', alertId);
      await alertEngineAPI.deleteAlert(alertId);
      setAlerts(prev => prev.filter(alert => alert.id !== alertId));
    } catch (err) {
      setError(err.message);
      throw err;
    }
  };

  // –ó–∞–≥—Ä—É–∑–∫–∞ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
  const loadMarketData = async () => {
    try {
      const data = await alertEngineAPI.getMarketData();
      setMarketData(data);
    } catch (err) {
      console.error('Failed to load market data:', err);
    }
  };

  // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ WebSocket —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  createEffect(() => {
    alertEngineAPI.connectWebSocket();
    
    const unsubscribe = alertEngineAPI.subscribe((notification) => {
      console.log('Alert notification:', notification);
      
      switch (notification.type) {
        case 'alert_triggered':
          // –û–±–Ω–æ–≤–∏—Ç—å –∞–ª–µ—Ä—Ç –∏–ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
          setAlerts(prev => prev.map(alert => 
            alert.id === notification.alert_id 
              ? { ...alert, last_triggered: notification.timestamp }
              : alert
          ));
          
          // –ü–æ–∫–∞–∑–∞—Ç—å –±—Ä–∞—É–∑–µ—Ä–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
          if (Notification.permission === 'granted') {
            new Notification(`Alert: ${notification.symbol}`, {
              body: `Price ${notification.condition} ${notification.target_price}`,
              icon: '/crypto-icon.png'
            });
          }
          break;
          
        case 'price_update':
          // –û–±–Ω–æ–≤–∏—Ç—å —Ä—ã–Ω–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
          setMarketData(prev => ({
            ...prev,
            [notification.symbol]: notification.price_data
          }));
          break;
          
        case 'connection_status':
          setConnected(notification.connected);
          break;
      }
    });

    onCleanup(unsubscribe);
  });

  // –ù–∞—á–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
  createEffect(() => {
    loadAlerts();
    loadMarketData();
    
    // –ó–∞–ø—Ä–æ—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    if (Notification.permission === 'default') {
      Notification.requestPermission();
    }
  });

  return {
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    alerts,
    marketData,
    loading,
    error,
    connected,
    
    // –î–µ–π—Å—Ç–≤–∏—è
    loadAlerts,
    createAlert,
    deleteAlert,
    loadMarketData
  };
}

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
export function AlertEngineStatus() {
  const [health, setHealth] = createSignal(null);
  const [stats, setStats] = createSignal(null);

  const checkHealth = async () => {
    try {
      const healthData = await alertEngineAPI.getHealth();
      const statsData = await alertEngineAPI.getStats();
      setHealth(healthData);
      setStats(statsData);
    } catch (error) {
      setHealth({ status: 'error', message: error.message });
    }
  };

  createEffect(() => {
    checkHealth();
    const interval = setInterval(checkHealth, 30000); // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫
    onCleanup(() => clearInterval(interval));
  });

  return (
    <div class="alert-engine-status">
      <h3>Alert Engine Status</h3>
      
      {health() && (
        <div class={`status ${health().status}`}>
          <span class="indicator"></span>
          {health().status === 'ok' ? 'Connected' : 'Disconnected'}
          {health().message && <span class="message">: {health().message}</span>}
        </div>
      )}
      
      {stats() && (
        <div class="stats">
          <div>Active Alerts: {stats().active_alerts}</div>
          <div>Monitored Symbols: {stats().monitored_symbols}</div>
          <div>Uptime: {stats().uptime} seconds</div>
          <div>Last Update: {new Date(stats().last_update * 1000).toLocaleTimeString()}</div>
        </div>
      )}
      
      <style>{`
        .alert-engine-status {
          padding: 1rem;
          border: 1px solid #ddd;
          border-radius: 8px;
          margin: 1rem 0;
        }
        
        .status {
          display: flex;
          align-items: center;
          margin: 0.5rem 0;
        }
        
        .indicator {
          width: 10px;
          height: 10px;
          border-radius: 50%;
          margin-right: 8px;
        }
        
        .status.ok .indicator {
          background-color: #4caf50;
        }
        
        .status.error .indicator {
          background-color: #f44336;
        }
        
        .stats {
          margin-top: 1rem;
          font-size: 0.9rem;
          color: #666;
        }
        
        .stats div {
          margin: 0.25rem 0;
        }
      `}</style>
    </div>
  );
}

export default alertEngineAPI;